#include <iostream>
#include <fstream>
#include <cmath>
#include <algorithm>

#include "TCanvas.h"
#include "TFile.h"
#include "TH1.h"
#include "TH2.h"
#include "TF1.h"
#include "TLegend.h"
#include "TLatex.h"

struct ParticleType {
  std::string type_name;
  int colour;

  double n_selected;
  double n_total;

  TH2F* hParticleEvdE;
  TH1F* hProfile;
  TF1* particle_band_gaussian;
};

struct Arm{
  std::string armname;
  TH2F* hEvdEAll;
  TH2F* hEvdEBand;
  TH1F* hBandProfile;
  TH1F* hBandRMS;
  TH1F* hDetRMS;

  int n_entry_threshold;  // the number of entries that we determine as the start of a peak
  int first_dE_of_band; // which is the dE value at the start of the band

  std::vector<ParticleType*> particle_types;

  double average_det_rms;

  TF1* extracted_band_gaussian;
};

struct Case {
  std::string identifier;
  std::string label;
  std::vector<Arm*> arms;

  std::string input_filename;
  std::string baseplotname;
  int n_entry_threshold;  // the number of entries that we determine as the start of a peak
  int first_dE_of_band; // which is the dE value at the start of the band

  double dE_scale_factor; // want to scale the MC to the data
} data, MC;

void ExtractProtonBand_Algorithm(Arm* this_arm);
int GetNPeaks(TH1* hist, int n_entry_threshold);
int FindNextPeak(TH1* hist, int start_bin, int n_entry_threshold);
int CalculateEfficienciesAndPurities(Arm* this_arm);
TH2F* ScaleEvdEPlot(TH2F* hist, double scale_factor);
void ExtractProtonBand_GraphicalCut(Arm* this_arm);

double energy_range_low = 2500;
double energy_range_high = 10000;

void DataAndMC() {
  data.identifier = "data"; data.label = "#bf{#it{Data}}";
  data.input_filename = "~/data/out/v94/total.root";
  data.baseplotname = "TME_Al50_EvdE/all_particles/ARM_EvdE";
  data.n_entry_threshold = 15;
  data.first_dE_of_band = 1900;
  data.dE_scale_factor = 1;


  MC.identifier = "MC"; MC.label = "#bf{#it{Monte Carlo}}";
  MC.input_filename = "plots_2015-03-04.root";
  MC.baseplotname = "hAll_EvdE_ARM";
  MC.n_entry_threshold = 2;
  MC.first_dE_of_band = 2000;
  MC.dE_scale_factor = 0.93;

  std::vector<Case*> cases;
  cases.push_back(&data);
  cases.push_back(&MC);

  // Loop through and extract the proton bands
  for (std::vector<Case*>::iterator i_case = cases.begin(); i_case != cases.end(); ++i_case) {
    Arm* left_arm = new Arm; Arm* right_arm = new Arm;
    left_arm->armname = "SiL"; right_arm->armname = "SiR";
    (*i_case)->arms.push_back(left_arm); (*i_case)->arms.push_back(right_arm);

    TFile* file = new TFile((*i_case)->input_filename.c_str(), "READ");
    // Initialise everything
    for (std::vector<Arm*>::iterator i_arm = (*i_case)->arms.begin(); i_arm != (*i_case)->arms.end(); ++i_arm) {
      (*i_arm)->n_entry_threshold = (*i_case)->n_entry_threshold;
      (*i_arm)->first_dE_of_band = (*i_case)->first_dE_of_band;

      std::string histname = (*i_case)->baseplotname;
      histname.replace((*i_case)->baseplotname.find("ARM"), 3, (*i_arm)->armname);
      (*i_arm)->hEvdEAll = (TH2F*) (file->Get(histname.c_str()))->Clone();
      (*i_arm)->hEvdEAll->SetDirectory(0);

      // Scale the total EvdE plot
      (*i_arm)->hEvdEAll = ScaleEvdEPlot((*i_arm)->hEvdEAll, (*i_case)->dE_scale_factor);

      // After scaling need to reformat everthing
      (*i_arm)->hEvdEAll->SetStats(false);
      (*i_arm)->hEvdEAll->SetTitle("");
      (*i_arm)->hEvdEAll->SetXTitle("E_{1} + E_{2} [keV]");
      (*i_arm)->hEvdEAll->SetYTitle("E_{1} [keV]");
      (*i_arm)->hEvdEAll->SetZTitle("Number of Events");
      (*i_arm)->hEvdEAll->SetMaximum(4e2);
      (*i_arm)->hEvdEAll->GetYaxis()->SetTitleOffset(1.4);

      ParticleType* proton_stopped = new ParticleType; proton_stopped->type_name = "proton_stopped"; proton_stopped->colour = kRed;
      ParticleType* proton_not_stopped = new ParticleType; proton_not_stopped->type_name = "proton_not_stopped"; proton_not_stopped->colour = kBlack;
      ParticleType* deuteron = new ParticleType; deuteron->type_name = "deuteron"; deuteron->colour = kCyan;
      ParticleType* triton = new ParticleType; triton->type_name = "triton"; triton->colour = kMagenta;
      ParticleType* alpha = new ParticleType; alpha->type_name = "alpha"; alpha->colour = kSpring;
      (*i_arm)->particle_types.push_back(proton_stopped); (*i_arm)->particle_types.push_back(proton_not_stopped); 
      (*i_arm)->particle_types.push_back(deuteron); (*i_arm)->particle_types.push_back(triton); (*i_arm)->particle_types.push_back(alpha);

      for (std::vector<ParticleType*>::iterator i_particle_type = (*i_arm)->particle_types.begin(); i_particle_type != (*i_arm)->particle_types.end(); ++i_particle_type) {
	std::string histname = "hEvdE_" + (*i_arm)->armname + "_" + (*i_particle_type)->type_name;
	(*i_particle_type)->hParticleEvdE = (TH2F*) file->Get(histname.c_str());
	if ( (*i_particle_type)->hParticleEvdE) {
	  (*i_particle_type)->hParticleEvdE->SetDirectory(0);
	  (*i_particle_type)->hParticleEvdE = ScaleEvdEPlot((*i_particle_type)->hParticleEvdE, (*i_case)->dE_scale_factor);

	  int n_bins = (*i_particle_type)->hParticleEvdE->GetXaxis()->GetNbins();
	  double min_x = (*i_particle_type)->hParticleEvdE->GetXaxis()->GetXmin();
	  double max_x = (*i_particle_type)->hParticleEvdE->GetXaxis()->GetXmax();

	  histname += "_profile";
	  (*i_particle_type)->hProfile = new TH1F(histname.c_str(), histname.c_str(), n_bins,min_x,max_x);
	  (*i_particle_type)->hProfile->SetDirectory(0);

	}
	else {
	  (*i_particle_type)->hProfile = NULL;
	}
      }      

      std::string canvasname = "c_" + (*i_case)->identifier + "_" + (*i_arm)->armname;
      TCanvas* c = new TCanvas(canvasname.c_str(), canvasname.c_str());
      c->SetLogz(1);
      c->SetRightMargin(0.15);
      std::cout << canvasname << std::endl;

      //      ExtractProtonBand_Algorithm(*i_arm);
      ExtractProtonBand_GraphicalCut(*i_arm);

      (*i_arm)->hEvdEBand->SetStats(false);

      (*i_arm)->hEvdEBand->GetYaxis()->SetRangeUser(0,3000);
      (*i_arm)->hEvdEBand->Draw("COLZ");
      //      (*i_arm)->hEvdEAll->Draw("COLZ");

      TLatex text;
      text.SetTextAlign(12);
      text.DrawLatex(15000, 2500, (*i_case)->label.c_str());


    } // end loop through arms
    file->Close();
  } // end loop through cases

  // Calculate the detector smear
  // Loop through the arms of data and MC at the same time
  for (std::vector<Arm*>::iterator i_data_arm = data.arms.begin(), i_MC_arm = MC.arms.begin();
       i_data_arm != data.arms.end() && i_MC_arm != MC.arms.end();
       ++i_data_arm, ++i_MC_arm) {
    TH1F* hProfile_data = (*i_data_arm)->hBandProfile;
    TH1F* hProfile_MC = (*i_MC_arm)->hBandProfile;

    int n_bins_x = hProfile_data->GetXaxis()->GetNbins();
    double min_x = hProfile_data->GetXaxis()->GetXmin();
    double max_x = hProfile_data->GetXaxis()->GetXmax();
    std::string histname = hProfile_data->GetName();
    histname += "_RMS";
    (*i_data_arm)->hBandRMS = new TH1F(histname.c_str(), "", n_bins_x,min_x,max_x);
    (*i_MC_arm)->hBandRMS = new TH1F(histname.c_str(), "", n_bins_x,min_x,max_x);

    histname = hProfile_data->GetName();
    histname += "_DetRMS";
    (*i_data_arm)->hDetRMS = new TH1F(histname.c_str(), "", 10,0,100);
    (*i_data_arm)->hDetRMS->SetXTitle("#sigma_{det} [keV]");
    (*i_data_arm)->hDetRMS->SetYTitle("Number of Bins");
    (*i_MC_arm)->hDetRMS = new TH1F(histname.c_str(), "", 10,0,100);

    double total_det_rms = 0;
    int n_good_det_rms = 0;
    for (int i_bin = 1; i_bin <= n_bins_x; ++i_bin) {
      double data_rms = hProfile_data->GetBinError(i_bin);
      double MC_rms = hProfile_MC->GetBinError(i_bin);

      (*i_data_arm)->hBandRMS->SetBinContent(i_bin, data_rms);
      (*i_MC_arm)->hBandRMS->SetBinContent(i_bin, MC_rms);

      if (data_rms > MC_rms) {
	++n_good_det_rms;
	double det_rms = std::sqrt(data_rms*data_rms - MC_rms*MC_rms);
	(*i_data_arm)->hDetRMS->Fill(det_rms);
	total_det_rms += det_rms;
	//	std::cout << "Bin #" << i_bin << ": data_rms = " << data_rms << ", MC = " << MC_rms << ", det_rms = " << det_rms << std::endl;
      }
    }
    (*i_MC_arm)->average_det_rms = total_det_rms / n_good_det_rms;
    std::cout << (*i_data_arm)->armname << " Average Det RMS = " << (*i_MC_arm)->average_det_rms << std::endl;

    // Calculate the variance
    double det_variance = 0;
    n_good_det_rms = 0;
    for (int i_bin = 1; i_bin <= n_bins_x; ++i_bin) {
      double data_rms = hProfile_data->GetBinError(i_bin);
      double MC_rms = hProfile_MC->GetBinError(i_bin);

      if (data_rms > MC_rms) {
	++n_good_det_rms;
	double det_rms = std::sqrt(data_rms*data_rms - MC_rms*MC_rms);
	det_variance += (det_rms - (*i_MC_arm)->average_det_rms)*(det_rms - (*i_MC_arm)->average_det_rms);
	//	std::cout << "Bin #" << i_bin << ": data_rms = " << data_rms << ", MC = " << MC_rms << ", det_rms = " << det_rms << std::endl;
      }
    }
    det_variance = std::sqrt(det_variance / n_good_det_rms);
    std::cout << (*i_data_arm)->armname << " Variance = " << det_variance << std::endl;
    (*i_MC_arm)->average_det_rms = (*i_MC_arm)->average_det_rms + det_variance;

    CalculateEfficienciesAndPurities(*i_MC_arm);

    // plot the smeared particle profiles
    std::string canvasname = "c_" + (*i_MC_arm)->armname + "_profiles";
    TCanvas* c = new TCanvas(canvasname.c_str(), canvasname.c_str());

    TLegend *leg = new TLegend(0.61,0.58,0.81,0.78);
    leg->SetBorderSize(0);
    leg->SetTextSize(0.04);
    leg->SetFillColor(kWhite);
    (*i_MC_arm)->hBandProfile->SetLineWidth(2);
    //    (*i_MC_arm)->hBandProfile->Draw();
    
    for (std::vector<ParticleType*>::iterator i_particle_type = (*i_MC_arm)->particle_types.begin(); i_particle_type != (*i_MC_arm)->particle_types.end(); ++i_particle_type) {
      (*i_particle_type)->hProfile->SetStats(false);
      (*i_particle_type)->hProfile->SetTitle("");
      (*i_particle_type)->hProfile->SetXTitle("E_{1} + E_{2} [keV]");
      (*i_particle_type)->hProfile->GetYaxis()->SetTitleOffset(1.3);
      (*i_particle_type)->hProfile->SetYTitle("E_{1} [keV]");
      (*i_particle_type)->hProfile->SetMaximum(10000);
      (*i_particle_type)->hProfile->SetLineColor((*i_particle_type)->colour);
      (*i_particle_type)->hProfile->SetLineWidth(2);
      (*i_particle_type)->hProfile->Draw("SAME");

      std::string label = (*i_particle_type)->type_name;
      std::replace(label.begin(), label.end(), '_', ' ');
      leg->AddEntry((*i_particle_type)->hProfile, label.c_str(), "l");
    }
    leg->Draw();
  }

  for (std::vector<Arm*>::iterator i_arm = data.arms.begin(); i_arm != data.arms.end(); ++i_arm) {
    std::string canvasname = "c_detRMS_" + (*i_arm)->armname;
    TCanvas* c1 = new TCanvas(canvasname.c_str(), canvasname.c_str());

    (*i_arm)->hDetRMS->SetLineWidth(2);
    (*i_arm)->hDetRMS->Fit("gaus");
    (*i_arm)->hDetRMS->SetStats(false);
    (*i_arm)->hDetRMS->Draw("HIST E");
  }    

  // Write everything to an output file
  TFile* output_file = new TFile("proton_band.root", "RECREATE");

  for (std::vector<Case*>::iterator i_case = cases.begin(); i_case != cases.end(); ++i_case) {

    for (std::vector<Arm*>::iterator i_arm = (*i_case)->arms.begin(); i_arm != (*i_case)->arms.end(); ++i_arm) {

      if ((*i_arm)->hEvdEAll) {
	(*i_arm)->hEvdEAll->Write();
      }
      if ((*i_arm)->hEvdEBand) {
	(*i_arm)->hEvdEBand->Write();
      }
      if ((*i_arm)->hBandProfile) {
	(*i_arm)->hBandProfile->Write();
      }
      /*      if ((*i_arm)->extracted_band_gaussian) {
	(*i_arm)->extracted_band_gaussian->Write();
      }
      */

      for (std::vector<ParticleType*>::iterator i_particle_type = (*i_arm)->particle_types.begin(); i_particle_type != (*i_arm)->particle_types.end(); ++i_particle_type) {
	if ((*i_particle_type)->hParticleEvdE) {
	  (*i_particle_type)->hParticleEvdE->Write();
	}
	if ((*i_particle_type)->hProfile) {
	  (*i_particle_type)->hProfile->Write();
	}
	/*	if ((*i_particle_type)->particle_band_gaussian) {
	  (*i_particle_type)->particle_band_gaussian->Write();
	}
	*/
      }
    }
  }
}

TH2F* ScaleEvdEPlot(TH2F* hist, double scale_factor) {

  // Go through each bin and change the y-axis
  int n_bins_x = hist->GetXaxis()->GetNbins(); double min_x = hist->GetXaxis()->GetXmin(); double max_x = hist->GetXaxis()->GetXmax();
  int n_bins_y = hist->GetYaxis()->GetNbins(); double min_y = hist->GetYaxis()->GetXmin(); double max_y = hist->GetYaxis()->GetXmax();
  std::string histname = hist->GetName();
  histname += "_scaled";
  TH2F* hist_scaled = new TH2F(histname.c_str(), "", n_bins_x,min_x,max_x, n_bins_y,min_y,max_y);
  hist_scaled->SetDirectory(0);

  for (int i_bin = 1; i_bin <= n_bins_x; ++i_bin) {
    double x_energy = hist->GetXaxis()->GetBinCenter(i_bin);
    for (int j_bin = 1; j_bin <= n_bins_y; ++j_bin) {
      double old_y_energy = hist->GetYaxis()->GetBinCenter(j_bin);
      double new_y_energy = old_y_energy * scale_factor;
      //      std::cout << old_y_energy << " --> " << new_y_energy << std::endl;
      double old_bin_content = hist->GetBinContent(i_bin, j_bin);
      hist_scaled->Fill(x_energy, new_y_energy, old_bin_content);
    }
  }
  return hist_scaled;
}

void ExtractProtonBand_GraphicalCut(Arm* this_arm) {

  int n_bins_x = this_arm->hEvdEAll->GetXaxis()->GetNbins();
  int min_x = this_arm->hEvdEAll->GetXaxis()->GetXmin();
  int max_x = this_arm->hEvdEAll->GetXaxis()->GetXmax();
  int n_bins_y = this_arm->hEvdEAll->GetYaxis()->GetNbins();
  int min_y = this_arm->hEvdEAll->GetYaxis()->GetXmin();
  int max_y = this_arm->hEvdEAll->GetYaxis()->GetXmax();
        
  std::string histname = "hEvdEBand_" + this_arm->armname;
  this_arm->hEvdEBand = new TH2F(histname.c_str(), histname.c_str(), n_bins_x,min_x,max_x, n_bins_y,min_y,max_y);
  this_arm->hEvdEBand->SetDirectory(0);
  this_arm->hEvdEBand->SetStats(false);
  this_arm->hEvdEBand->SetTitle("");
  this_arm->hEvdEBand->SetXTitle("E_{1} + E_{2} [keV]");
  this_arm->hEvdEBand->SetYTitle("E_{1} [keV]");
  this_arm->hEvdEBand->GetYaxis()->SetTitleOffset(1.3);
  this_arm->hEvdEBand->SetZTitle("Number of Events");

  
    
  histname = "hBandProfile_" + this_arm->armname;
  this_arm->hBandProfile = new TH1F(histname.c_str(), histname.c_str(), n_bins_x,min_x,max_x);
  this_arm->hBandProfile->SetDirectory(0);
  this_arm->hBandProfile->SetStats(false);
  this_arm->hBandProfile->SetTitle("");
  this_arm->hBandProfile->SetXTitle("E_{1} + E_{2} [keV]");
  this_arm->hBandProfile->SetYTitle("E_{1} [keV]");
  this_arm->hBandProfile->GetYaxis()->SetTitleOffset(1.3);


  // The cuts
  double x_1 = 0, y_1 = 2000, x_2 = 4000, y_2 = 0;
  double gradient = (y_2 - y_1) / (x_2 - x_1);
  double offset = y_1;
  TF1* electron_spot_cut = new TF1("electron_spot_cut", "[0]*x + [1]", 0, 15000);
  electron_spot_cut->SetLineColor(kBlack);
  electron_spot_cut->SetParameter(0, gradient);
  electron_spot_cut->SetParameter(1, offset);

  double punch_through_yoffset = 300;
  TF1* punch_through_cut = new TF1("punch_through_cut", "[0]", 0, 25000);
  punch_through_cut->SetLineColor(kBlack);
  punch_through_cut->SetParameter(0, punch_through_yoffset);

  // Cut to remove the remaining deuteron band                                                                                                      
  TF1* deuteron_cut = new TF1("deuteron_cut", "[0]*TMath::Exp([1]*x) + [2]", 0, 25000);
  deuteron_cut->SetLineColor(kBlack);
  deuteron_cut->SetParameter(0, 4500);
  deuteron_cut->SetParameter(1, -0.0004);
  deuteron_cut->SetParameter(2, 500);

  /*  TF1* lower_cut = new TF1("lower_cut", "[0]*TMath::Exp([1]*x) + [2]", 0, 25000);
  lower_cut->SetLineColor(kBlack);
  lower_cut->SetParameter(0, 2500);
  lower_cut->SetParameter(1, -0.0004);
  lower_cut->SetParameter(2, 100);
  */
  //    evde_hists[i_arm]->Fit(deuteron_cut, "R");

  for (int i_bin = 1; i_bin <= n_bins_x; ++i_bin) {
    for (int j_bin = 1; j_bin <= n_bins_y; ++j_bin) {

      double x_coord = this_arm->hEvdEBand->GetXaxis()->GetBinCenter(i_bin);
      double y_coord = this_arm->hEvdEBand->GetYaxis()->GetBinCenter(j_bin);
      double bin_content = this_arm->hEvdEAll->GetBinContent(i_bin, j_bin);
      if (bin_content < 10 ||
	  y_coord < electron_spot_cut->Eval(x_coord) ||
	  y_coord < punch_through_cut->Eval(x_coord) ||
	  y_coord > deuteron_cut->Eval(x_coord) ) {
	//          y_coord < lower_cut->Eval(x_coord) ||
	
	this_arm->hEvdEBand->SetBinContent(i_bin, j_bin, 0);                                                                                       
      }
      else {
	this_arm->hEvdEBand->SetBinContent(i_bin, j_bin, bin_content);
      }
    }

    // Now create fill the profile plot for this energy bin
    TH1D* hProjection = this_arm->hEvdEBand->ProjectionY("_py", i_bin, i_bin);
    double mean = hProjection->GetMean();
    double rms = hProjection->GetRMS();
    //    output << i_energy << " " << mean << " " << rms << std::endl;
    this_arm->hBandProfile->SetBinContent(i_bin, mean);
    this_arm->hBandProfile->SetBinError(i_bin, rms);

  }
  this_arm->hEvdEBand->ResetStats();
  this_arm->hEvdEAll->Draw("COLZ");
  electron_spot_cut->Draw("LSAME");                                                                                                           
  punch_through_cut->Draw("LSAME");                                                                                                           
  deuteron_cut->Draw("LSAME");
  //  lower_cut->Draw("LSAME");

  TH1D* hProjection = this_arm->hEvdEBand->ProjectionX();
  int low_integral_bin = hProjection->FindBin(energy_range_low);
  int high_integral_bin = hProjection->FindBin(energy_range_high);
  double error;
  double n_protons = hProjection->IntegralAndError(low_integral_bin, high_integral_bin, error);
  std::cout << "Number of measured protons (" << energy_range_low << " - " << energy_range_high << " keV) = " << n_protons << " +- " << error << std::endl;
}

void ExtractProtonBand_Algorithm(Arm* this_arm) {

  double low_energy_cut = 1000; // keV
  double high_energy_cut = 10000; // keV
  
  int n_bins_x = this_arm->hEvdEAll->GetXaxis()->GetNbins();
  int min_x = this_arm->hEvdEAll->GetXaxis()->GetXmin();
  int max_x = this_arm->hEvdEAll->GetXaxis()->GetXmax();
  int n_bins_y = this_arm->hEvdEAll->GetYaxis()->GetNbins();
  int min_y = this_arm->hEvdEAll->GetYaxis()->GetXmin();
  int max_y = this_arm->hEvdEAll->GetYaxis()->GetXmax();
        
  std::string histname = "hEvdEBand_" + this_arm->armname;
  this_arm->hEvdEBand = new TH2F(histname.c_str(), histname.c_str(), n_bins_x,min_x,max_x, n_bins_y,min_y,max_y);
  this_arm->hEvdEBand->SetDirectory(0);
    
  histname = "hBandProfile_" + this_arm->armname;
  this_arm->hBandProfile = new TH1F(histname.c_str(), histname.c_str(), n_bins_x,min_x,max_x);
  this_arm->hBandProfile->SetDirectory(0);
  
  /*  histname = "hNPeaks_" + this_arm->armname;
  TH1F* hNPeaks = new TH1F(histname.c_str(), "", n_bins_x,min_x,max_x);
  hNPeaks->SetDirectory(0);
  */

  // Loop through the projection of each energy to try and find the proton band
  int start_bin = this_arm->hEvdEAll->GetXaxis()->FindBin(low_energy_cut);
  int stop_bin = this_arm->hEvdEAll->GetXaxis()->FindBin(high_energy_cut);
  for (int i_bin = start_bin; i_bin <= stop_bin; ++i_bin) {
    double i_energy = this_arm->hEvdEAll->GetXaxis()->GetBinLowEdge(i_bin);
    
    TH1* hProjection = this_arm->hEvdEAll->ProjectionY("_py", i_bin, i_bin);
    
    int n_peaks = GetNPeaks(hProjection, this_arm->n_entry_threshold);
    //    hNPeaks->Fill(i_energy, n_peaks);
    
    // Loop through the peaks
    int peak_start_bin;
    bool found_peak = false;
    for (int i_peak = 0; i_peak < n_peaks; ++i_peak) {
      // Get the location of the start of this peak
      int counter = 0;
      peak_start_bin = 1;
      while (counter <= i_peak) {
	peak_start_bin = FindNextPeak(hProjection, peak_start_bin, this_arm->n_entry_threshold);
	++counter;
      }
      
      // Is this peak close enough to where we were last time
      double peak_start_dE = hProjection->GetBinLowEdge(peak_start_bin);
      int content = hProjection->GetBinContent(peak_start_bin);
      double difference = std::fabs(peak_start_dE - this_arm->first_dE_of_band);
      //	output << i_energy << ": Peak #" << i_peak+1 << " of " << n_peaks << ": Peak Start = " << peak_start_bin << ": " << this_arm->first_dE_of_band << " - " << peak_start_dE << " = " << difference << " (" << content << " entries)" << std::endl;
      if (difference < 250) {
	// This is the peak we want to take for the selected band
	found_peak = true;
	this_arm->first_dE_of_band = peak_start_dE;
	break; // from the loop through the peaks
      }
    }
    if (found_peak == false) {
      continue; // to the next energy bin
    }
    // Now fill in the bins until we get a bin content that is not part of the peak
    int j_bin = peak_start_bin;
    int bin_content = hProjection->GetBinContent(j_bin);
    while (bin_content > this_arm->n_entry_threshold) {
      bin_content = hProjection->GetBinContent(j_bin);
      if (bin_content > this_arm->n_entry_threshold) {
	this_arm->hEvdEBand->SetBinContent(i_bin, j_bin, bin_content);
      }
      ++j_bin;
    }
    
    hProjection = this_arm->hEvdEBand->ProjectionY("_py", i_bin, i_bin);
    double mean = hProjection->GetMean();
    double rms = hProjection->GetRMS();
    //    output << i_energy << " " << mean << " " << rms << std::endl;
    this_arm->hBandProfile->SetBinContent(i_bin, mean);
    this_arm->hBandProfile->SetBinError(i_bin, rms);
    //	std::cout << "Bin #" << i_bin << ": bin_location = " << peak_start_bin << std::endl;
  } // end loop through energy bins
}

// Gets the number of "peaks", just based on the number of times we go to zero entries
int GetNPeaks(TH1* hist, int n_entry_threshold) {
  int n_bins = hist->GetNbinsX();
  int n_peaks = -1; // start at -1 since we will always go through the while loop once, even if we don't find the next peak
  int peak_start_bin = 1;

  while (peak_start_bin != n_bins) {
    peak_start_bin = FindNextPeak(hist, peak_start_bin, n_entry_threshold);
    ++n_peaks;
  }
  return n_peaks;
}

// Finds the next peak and returns the bin number
int FindNextPeak(TH1* hist, int start_bin, int n_entry_threshold) {
  int n_bins = hist->GetNbinsX();
  int return_bin = n_bins;
  int prev_bin_content = hist->GetBinContent(start_bin);
  
  for (int i_bin = start_bin+1; i_bin <= n_bins; ++i_bin) {
    int bin_content = hist->GetBinContent(i_bin);

    if (prev_bin_content <= n_entry_threshold && bin_content > n_entry_threshold) {
      return_bin = i_bin;
      break;
    }   
    prev_bin_content = bin_content;
  }
  return return_bin;
}

int CalculateEfficienciesAndPurities(Arm* this_arm) {
  // Want to know the efficiency and purity of the cut based on MC

  TH1F* hExtractedBand = this_arm->hBandProfile;

  double det_rms = this_arm->average_det_rms; // the extra detector smearing
  std::cout << this_arm->armname << std::endl;

  // Set things up for each particle type
  for (std::vector<ParticleType*>::iterator i_particle_type = this_arm->particle_types.begin(); i_particle_type != this_arm->particle_types.end(); ++i_particle_type) {
    (*i_particle_type)->n_selected = 0;
    (*i_particle_type)->n_total = 0;
    
    if (!(*i_particle_type)->hParticleEvdE) {
      std::cout << "ERROR: Need histograms of each particle type to calculate efficiencies" << std::endl;
      std::cout << "Quitting" << std::endl;
      return 1;
    }	
  }
    
  // Loop through the extracted band profile
  int n_bins = hExtractedBand->GetNbinsX();
  int low_energy_range_bin = hExtractedBand->FindBin(energy_range_low);
  int high_energy_range_bin = hExtractedBand->FindBin(energy_range_high);
  for (int i_bin = low_energy_range_bin; i_bin <= high_energy_range_bin; ++i_bin) {
    double i_energy = hExtractedBand->GetBinLowEdge(i_bin);
    double mean = hExtractedBand->GetBinContent(i_bin);
    double rms = hExtractedBand->GetBinError(i_bin);
    
    if (mean < 0.1) {
      continue;
    }
    
    // Want to add the detector smearing
    double new_rms = std::sqrt(rms*rms + det_rms*det_rms);
    hExtractedBand->SetBinError(i_bin, new_rms);
    
    this_arm->extracted_band_gaussian = new TF1("extracted_band_gaussian", "TMath::Gaus(x, 0, [0], 1)");
    this_arm->extracted_band_gaussian->SetParameter(0, new_rms);
    
    int integral_low = mean - 1*new_rms;
    int integral_high = mean + 1*new_rms;
    
    // Loop through the particle types and count how many are within the cut and how many are in that energy in total
    for (std::vector<ParticleType*>::iterator i_particle_type = this_arm->particle_types.begin(); 
	 i_particle_type != this_arm->particle_types.end(); ++i_particle_type) {
      
      // Need to add detector resolution to each particle band
      TH1D* hProjection = (*i_particle_type)->hParticleEvdE->ProjectionY("_py", i_bin, i_bin);
      double particle_mean = hProjection->GetMean();
      double particle_rms = hProjection->GetRMS();

      double new_particle_rms = std::sqrt(particle_rms*particle_rms + det_rms*det_rms);
      (*i_particle_type)->hProfile->SetBinContent(i_bin, particle_mean);
      (*i_particle_type)->hProfile->SetBinError(i_bin, new_particle_rms);

      if (particle_mean < 0.1 || new_particle_rms < 0.1) {
	continue;
      }
      (*i_particle_type)->particle_band_gaussian = new TF1("particle_band_gaussian", "TMath::Gaus(x, [0], [1], 1)", particle_mean-10*new_particle_rms, particle_mean+10*new_particle_rms);
      (*i_particle_type)->particle_band_gaussian->SetParameter(0, particle_mean);
      (*i_particle_type)->particle_band_gaussian->SetParameter(1, new_particle_rms);

      double n_selected_this_bin = (*i_particle_type)->particle_band_gaussian->Integral(integral_low, integral_high);
      double n_total_this_bin = 1; // should be normalised...

      /*      if ((*i_particle_type)->type_name == "proton_stopped") {
	std::cout << i_energy << std::endl;
	std::cout << "Extracted Band: mean = " << mean << ", rms = " << new_rms << "Stopped Proton: mean = " << particle_mean << ", rms = " << new_particle_rms << std::endl;
	std::cout << "Integrating between " << integral_low << " and " << integral_high << " gives " << n_selected_this_bin << std::endl;
      }
      */

      (*i_particle_type)->n_selected += n_selected_this_bin;
      (*i_particle_type)->n_total += n_total_this_bin;
    } // end loop through particle types
  } // end loop through energy bins

  std::cout << "Efficiencies: " << std::endl;
  double total_in_cut = 0;
  for (std::vector<ParticleType*>::iterator i_particle_type = this_arm->particle_types.begin(); 
       i_particle_type != this_arm->particle_types.end(); ++i_particle_type) {

    std::cout << this_arm->armname 
	      << ": (n_" << (*i_particle_type)->type_name << "_in_cut / n_total_" << (*i_particle_type)->type_name + ") = " 
	      << (*i_particle_type)->n_selected << " / " << (*i_particle_type)->n_total << " = " 
	      << (double) (*i_particle_type)->n_selected / (*i_particle_type)->n_total << std::endl;

    total_in_cut += (*i_particle_type)->n_selected;
  }

  std::cout << "Purities: " << std::endl;
  for (std::vector<ParticleType*>::iterator i_particle_type = this_arm->particle_types.begin(); 
       i_particle_type != this_arm->particle_types.end(); ++i_particle_type) {
    
    std::cout << this_arm->armname 
	      << ": (n_" + (*i_particle_type)->type_name + "_in_cut / n_total_selected) = " 
	      << (*i_particle_type)->n_selected << " / " << total_in_cut << " = " 
	      << (double) (*i_particle_type)->n_selected / total_in_cut << std::endl;
  } // end loop through particles types

  return 0;
}
